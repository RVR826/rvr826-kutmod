\section{A program építése és a vizualizáció futtatása}

Ebben a részben bemutatom a \emph{Waypoint Module} és a vizualizációs alkalmazás építését, futtatását és különböző követelményeiket. Kitérek a szoftveres, hardveres előfeltételekre is.

\subsection{Futási környezet, hardveres és szoftveres követelmények}

A program forráskódját C++ nyelven készítettem el, a C++17-es verzió alapján. Mivel a nyelv lehetővé teszi a \emph{cross-platform} építést és futtatást, ezért az operációs rendszerre nincs sok követelmény. Bármilyen 64 bites operációs rendszeren futtatható, ahol natívan támogatva vannak a dupla pontosságú lebegőpontos számokkal végzett műveletek. A vizualizációs szoftver a Qt keretrendszer segítségével készült, így az is támogatja a \emph{cross-platform} funkciókat. Ezzel ellentétben mind a \emph{Waypoint Module}, mind a vizualizációs szoftver csak Linux rendszeren volt építve és futtatva a fejlesztési folyamatban.

Az általam készített modul teljes egésze a \emph{stack-en} fut, mivel a projekt keretein belül nem használható dinamikus memória. A beágyazott rendszerek (főleg járművek) esetén szükséges ismerni a program által használt memória mennyiségét, hiszen ez alapján tudják szabályozni a ráfordítandó erőforrásokat. A következő táblázatban található az útvonaltervező és azon belül a \emph{Waypoint Module stack size-a}.

\begin{table}[h]
    \centering
    \begin{tabular}{|c|c|}
        \hline
        \textbf{Könyvtár} & \textbf{Méret} \\
        \hline
        \hline
        
        Teljes útvonaltervező & 42.984.448 bájt (42,98 Mb) \\
        \hline
        Ebből a \emph{Waypoint Module} & 1712 bájt (1,71 Kb) \\
        \hline
    \end{tabular}
    \label{tab:stackSizes}
    \caption{Útvonaltervező \emph{stack size-a}}
\end{table}

\begin{note}
   A méretek változhatnak, ha az útvonaltervező, vagy bármelyik osztályának \emph{template} argumentumai változnak.
\end{note}

\subsection{A \emph{Waypoint Module} építése}
Mind az általam készített modul, mind a vizualizációs szoftver az építéshez a \emph{CMake build} rendszert használja. Ez viszont csak az alapját képezi az egész folyamatnak, hiszen minden \emph{subsystem-nek} és kompozitnak vannak függőségei. Ezen függőségek automatikus beszerzéséről és a megfelelő környezet kialakításáról a \emph{Dockerized Toolchain Interface} (később {\fontfamily{cmtt}\selectfont dti}) rendszer felelős. A projekt kontextusában a {\fontfamily{cmtt}\selectfont dti} egy elosztott architektúrát használ, amely több \emph{Docker} konténerre épül. Az ilyen megközelítés egyik előnye a felhasználók számára, hogy az adott feladathoz a megfelelő konténert tudják használni. A {\fontfamily{cmtt}\selectfont dti} API \emph{Gateway} egy egységes interfésszel biztosítja az összes konténerhez való elérést. A rendszer használatának előnyei:
\begin{itemize}
    \item \textbf{egységes interfész biztosítása a \emph{toolchain-hez}:} \\
    A felhasználónak elegendő csak a {\fontfamily{cmtt}\selectfont dti} eszközt ismernie (és a súgó funkció használatát), hogy az összes konténert használni tudja. Nincs szükség arra, hogy a felhasználó tudja, mely parancsokat melyik \emph{Docker} konténer hajtja végre, mivel ezt a rendszer automatikusan kezeli, és a parancsokat a megfelelő konténerbe továbbítja.

    \item \textbf{egyszerű bővíthetőség:} \\
    A felhasználók könnyen hozzáadhatnak új konténereket a rendszerhez anélkül, hogy új interfészt kellene készíteni és a használatát megtanulni, dokumentálni. Lehetőséget ad még ezek átlátható integrációjára a \emph{gateway} módosítása nélkül.
\end{itemize}

\begin{note}
    A {\fontfamily{cmtt}\selectfont dti} API \emph{Gateway} a telepítés után bármilyen \emph{bash} konzolból használható, csak internethozzáférés szükséges hozzá. Az utasítások felépítése a következő: {\fontfamily{cmtt}\selectfont dti <command> <options>}. A {\fontfamily{cmtt}\selectfont dti --help} segítségével nyitható meg a súgó.
\end{note}

\lstset{caption={Legfontosabb {\fontfamily{cmtt}\selectfont dti} utasítások}, label=src:buildCommands}
\begin{lstlisting}[language={bash}]
# build the project (or part) in release mode
dti build

# build the project (or part) in debug mode
dti build linux-x86_64-gcc-8-debug

# incremental build of the project,
# requires at least one normal build in it's respective build mode
dti build --build

# build the project and every dependency that cannot be found
dti build --build-packages="missing"

# run all unit tests in the current suite
dti test
\end{lstlisting}

\subsection{A vizualizációs szoftver építése és futtatása}
A vizualizációs szoftver építéséhez külön \emph{Docker} konténer áll rendelkezésre a {\fontfamily{cmtt}\selectfont dti}-on belül. Ezt a {\fontfamily{cmtt}\selectfont dti build-qt <options>} utasítás segítségével érhetjük el. Itt is lehetőség van a \emph{debug} és a \emph{release build-ek} elkülönítésére. A vizualizációs szoftver tekintetében ez különösen fontos, hiszen az elkészült implementációkat itt tudjuk futtatni, és \emph{debug} módban több helyen van lehetőség betekinteni az objektumok felépítésébe. \emph{Release} módban ez azért nem lehetséges, mert ebben a fordító magasszintű optimalizálással építi a szoftvert, ezért sok értéket kioptimalizálnak, és ezek számunkra elérhetetlenek.

Építés után a kész bináris állomány a \emph{./\_generated/build/linux-x86\_64-gcc-8/Debug/bin/qt\_visu} vagy a \emph{./\_generated/build/linux-x86\_64-gcc-8/Release/bin/qt\_visu} helyen található a \emph{build mode} függvényében. Ezt \emph{linux} rendszeren konzolból vagy akár közvetlenül a mappából is van lehetőség futtatni.

\begin{note}
    A fejlesztés alatt a \emph{Visual Studio Code} egyik bővítményét használtam a vizualizáció futtatására. A projektben adott volt az integrált futtatáshoz szükséges összes adat a {\fontfamily{cmtt}\selectfont launch.json}, {\fontfamily{cmtt}\selectfont settings.json} és {\fontfamily{cmtt}\selectfont tasks.json} állományokban. Ezek segítségével egy gombnyomással indítható a program, és beépített \emph{debug} ablak is a rendelkezésemre áll.
\end{note}